/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/stream-parser";
exports.ids = ["vendor-chunks/stream-parser"];
exports.modules = {

/***/ "(action-browser)/./node_modules/stream-parser/index.js":
/*!*********************************************!*\
  !*** ./node_modules/stream-parser/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Module dependencies.\n */\n\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar debug = __webpack_require__(/*! debug */ \"(action-browser)/./node_modules/debug/src/index.js\")('stream-parser');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Parser;\n\n/**\n * Parser states.\n */\n\nvar INIT        = -1;\nvar BUFFERING   = 0;\nvar SKIPPING    = 1;\nvar PASSTHROUGH = 2;\n\n/**\n * The `Parser` stream mixin works with either `Writable` or `Transform` stream\n * instances/subclasses. Provides a convenient generic \"parsing\" API:\n *\n *   _bytes(n, cb) - buffers \"n\" bytes and then calls \"cb\" with the \"chunk\"\n *   _skipBytes(n, cb) - skips \"n\" bytes and then calls \"cb\" when done\n *\n * If you extend a `Transform` stream, then the `_passthrough()` function is also\n * added:\n *\n *   _passthrough(n, cb) - passes through \"n\" bytes untouched and then calls \"cb\"\n *\n * @param {Stream} stream Transform or Writable stream instance to extend\n * @api public\n */\n\nfunction Parser (stream) {\n  var isTransform = stream && 'function' == typeof stream._transform;\n  var isWritable = stream && 'function' == typeof stream._write;\n\n  if (!isTransform && !isWritable) throw new Error('must pass a Writable or Transform stream in');\n  debug('extending Parser into stream');\n\n  // Transform streams and Writable streams get `_bytes()` and `_skipBytes()`\n  stream._bytes = _bytes;\n  stream._skipBytes = _skipBytes;\n\n  // only Transform streams get the `_passthrough()` function\n  if (isTransform) stream._passthrough = _passthrough;\n\n  // take control of the streams2 callback functions for this stream\n  if (isTransform) {\n    stream._transform = transform;\n  } else {\n    stream._write = write;\n  }\n}\n\nfunction init (stream) {\n  debug('initializing parser stream');\n\n  // number of bytes left to parser for the next \"chunk\"\n  stream._parserBytesLeft = 0;\n\n  // array of Buffer instances that make up the next \"chunk\"\n  stream._parserBuffers = [];\n\n  // number of bytes parsed so far for the next \"chunk\"\n  stream._parserBuffered = 0;\n\n  // flag that keeps track of if what the parser should do with bytes received\n  stream._parserState = INIT;\n\n  // the callback for the next \"chunk\"\n  stream._parserCallback = null;\n\n  // XXX: backwards compat with the old Transform API... remove at some point..\n  if ('function' == typeof stream.push) {\n    stream._parserOutput = stream.push.bind(stream);\n  }\n\n  stream._parserInit = true;\n}\n\n/**\n * Buffers `n` bytes and then invokes `fn` once that amount has been collected.\n *\n * @param {Number} n the number of bytes to buffer\n * @param {Function} fn callback function to invoke when `n` bytes are buffered\n * @api public\n */\n\nfunction _bytes (n, fn) {\n  assert(!this._parserCallback, 'there is already a \"callback\" set!');\n  assert(isFinite(n) && n > 0, 'can only buffer a finite number of bytes > 0, got \"' + n + '\"');\n  if (!this._parserInit) init(this);\n  debug('buffering %o bytes', n);\n  this._parserBytesLeft = n;\n  this._parserCallback = fn;\n  this._parserState = BUFFERING;\n}\n\n/**\n * Skips over the next `n` bytes, then invokes `fn` once that amount has\n * been discarded.\n *\n * @param {Number} n the number of bytes to discard\n * @param {Function} fn callback function to invoke when `n` bytes have been skipped\n * @api public\n */\n\nfunction _skipBytes (n, fn) {\n  assert(!this._parserCallback, 'there is already a \"callback\" set!');\n  assert(n > 0, 'can only skip > 0 bytes, got \"' + n + '\"');\n  if (!this._parserInit) init(this);\n  debug('skipping %o bytes', n);\n  this._parserBytesLeft = n;\n  this._parserCallback = fn;\n  this._parserState = SKIPPING;\n}\n\n/**\n * Passes through `n` bytes to the readable side of this stream untouched,\n * then invokes `fn` once that amount has been passed through.\n *\n * @param {Number} n the number of bytes to pass through\n * @param {Function} fn callback function to invoke when `n` bytes have passed through\n * @api public\n */\n\nfunction _passthrough (n, fn) {\n  assert(!this._parserCallback, 'There is already a \"callback\" set!');\n  assert(n > 0, 'can only pass through > 0 bytes, got \"' + n + '\"');\n  if (!this._parserInit) init(this);\n  debug('passing through %o bytes', n);\n  this._parserBytesLeft = n;\n  this._parserCallback = fn;\n  this._parserState = PASSTHROUGH;\n}\n\n/**\n * The `_write()` callback function implementation.\n *\n * @api private\n */\n\nfunction write (chunk, encoding, fn) {\n  if (!this._parserInit) init(this);\n  debug('write(%o bytes)', chunk.length);\n\n  // XXX: old Writable stream API compat... remove at some point...\n  if ('function' == typeof encoding) fn = encoding;\n\n  data(this, chunk, null, fn);\n}\n\n/**\n * The `_transform()` callback function implementation.\n *\n * @api private\n */\n\n\nfunction transform (chunk, output, fn) {\n  if (!this._parserInit) init(this);\n  debug('transform(%o bytes)', chunk.length);\n\n  // XXX: old Transform stream API compat... remove at some point...\n  if ('function' != typeof output) {\n    output = this._parserOutput;\n  }\n\n  data(this, chunk, output, fn);\n}\n\n/**\n * The internal buffering/passthrough logic...\n *\n * This `_data` function get's \"trampolined\" to prevent stack overflows for tight\n * loops. This technique requires us to return a \"thunk\" function for any\n * synchronous action. Async stuff breaks the trampoline, but that's ok since it's\n * working with a new stack at that point anyway.\n *\n * @api private\n */\n\nfunction _data (stream, chunk, output, fn) {\n  if (stream._parserBytesLeft <= 0) {\n    return fn(new Error('got data but not currently parsing anything'));\n  }\n\n  if (chunk.length <= stream._parserBytesLeft) {\n    // small buffer fits within the \"_parserBytesLeft\" window\n    return function () {\n      return process(stream, chunk, output, fn);\n    };\n  } else {\n    // large buffer needs to be sliced on \"_parserBytesLeft\" and processed\n    return function () {\n      var b = chunk.slice(0, stream._parserBytesLeft);\n      return process(stream, b, output, function (err) {\n        if (err) return fn(err);\n        if (chunk.length > b.length) {\n          return function () {\n            return _data(stream, chunk.slice(b.length), output, fn);\n          };\n        }\n      });\n    };\n  }\n}\n\n/**\n * The internal `process` function gets called by the `data` function when\n * something \"interesting\" happens. This function takes care of buffering the\n * bytes when buffering, passing through the bytes when doing that, and invoking\n * the user callback when the number of bytes has been reached.\n *\n * @api private\n */\n\nfunction process (stream, chunk, output, fn) {\n  stream._parserBytesLeft -= chunk.length;\n  debug('%o bytes left for stream piece', stream._parserBytesLeft);\n\n  if (stream._parserState === BUFFERING) {\n    // buffer\n    stream._parserBuffers.push(chunk);\n    stream._parserBuffered += chunk.length;\n  } else if (stream._parserState === PASSTHROUGH) {\n    // passthrough\n    output(chunk);\n  }\n  // don't need to do anything for the SKIPPING case\n\n  if (0 === stream._parserBytesLeft) {\n    // done with stream \"piece\", invoke the callback\n    var cb = stream._parserCallback;\n    if (cb && stream._parserState === BUFFERING && stream._parserBuffers.length > 1) {\n      chunk = Buffer.concat(stream._parserBuffers, stream._parserBuffered);\n    }\n    if (stream._parserState !== BUFFERING) {\n      chunk = null;\n    }\n    stream._parserCallback = null;\n    stream._parserBuffered = 0;\n    stream._parserState = INIT;\n    stream._parserBuffers.splice(0); // empty\n\n    if (cb) {\n      var args = [];\n      if (chunk) {\n        // buffered\n        args.push(chunk);\n      } else {\n        // passthrough\n      }\n      if (output) {\n        // on a Transform stream, has \"output\" function\n        args.push(output);\n      }\n      var async = cb.length > args.length;\n      if (async) {\n        args.push(trampoline(fn));\n      }\n      // invoke cb\n      var rtn = cb.apply(stream, args);\n      if (!async || fn === rtn) return fn;\n    }\n  } else {\n    // need more bytes\n    return fn;\n  }\n}\n\nvar data = trampoline(_data);\n\n/**\n * Generic thunk-based \"trampoline\" helper function.\n *\n * @param {Function} input function\n * @return {Function} \"trampolined\" function\n * @api private\n */\n\nfunction trampoline (fn) {\n  return function () {\n    var result = fn.apply(this, arguments);\n\n    while ('function' == typeof result) {\n      result = result();\n    }\n\n    return result;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHJlYW0tcGFyc2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyxpRUFBTzs7QUFFM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9zdHJlYW0tcGFyc2VyL2luZGV4LmpzPzUyYTgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc3RyZWFtLXBhcnNlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyO1xuXG4vKipcbiAqIFBhcnNlciBzdGF0ZXMuXG4gKi9cblxudmFyIElOSVQgICAgICAgID0gLTE7XG52YXIgQlVGRkVSSU5HICAgPSAwO1xudmFyIFNLSVBQSU5HICAgID0gMTtcbnZhciBQQVNTVEhST1VHSCA9IDI7XG5cbi8qKlxuICogVGhlIGBQYXJzZXJgIHN0cmVhbSBtaXhpbiB3b3JrcyB3aXRoIGVpdGhlciBgV3JpdGFibGVgIG9yIGBUcmFuc2Zvcm1gIHN0cmVhbVxuICogaW5zdGFuY2VzL3N1YmNsYXNzZXMuIFByb3ZpZGVzIGEgY29udmVuaWVudCBnZW5lcmljIFwicGFyc2luZ1wiIEFQSTpcbiAqXG4gKiAgIF9ieXRlcyhuLCBjYikgLSBidWZmZXJzIFwiblwiIGJ5dGVzIGFuZCB0aGVuIGNhbGxzIFwiY2JcIiB3aXRoIHRoZSBcImNodW5rXCJcbiAqICAgX3NraXBCeXRlcyhuLCBjYikgLSBza2lwcyBcIm5cIiBieXRlcyBhbmQgdGhlbiBjYWxscyBcImNiXCIgd2hlbiBkb25lXG4gKlxuICogSWYgeW91IGV4dGVuZCBhIGBUcmFuc2Zvcm1gIHN0cmVhbSwgdGhlbiB0aGUgYF9wYXNzdGhyb3VnaCgpYCBmdW5jdGlvbiBpcyBhbHNvXG4gKiBhZGRlZDpcbiAqXG4gKiAgIF9wYXNzdGhyb3VnaChuLCBjYikgLSBwYXNzZXMgdGhyb3VnaCBcIm5cIiBieXRlcyB1bnRvdWNoZWQgYW5kIHRoZW4gY2FsbHMgXCJjYlwiXG4gKlxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSBUcmFuc2Zvcm0gb3IgV3JpdGFibGUgc3RyZWFtIGluc3RhbmNlIHRvIGV4dGVuZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBQYXJzZXIgKHN0cmVhbSkge1xuICB2YXIgaXNUcmFuc2Zvcm0gPSBzdHJlYW0gJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3RyZWFtLl90cmFuc2Zvcm07XG4gIHZhciBpc1dyaXRhYmxlID0gc3RyZWFtICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIHN0cmVhbS5fd3JpdGU7XG5cbiAgaWYgKCFpc1RyYW5zZm9ybSAmJiAhaXNXcml0YWJsZSkgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHBhc3MgYSBXcml0YWJsZSBvciBUcmFuc2Zvcm0gc3RyZWFtIGluJyk7XG4gIGRlYnVnKCdleHRlbmRpbmcgUGFyc2VyIGludG8gc3RyZWFtJyk7XG5cbiAgLy8gVHJhbnNmb3JtIHN0cmVhbXMgYW5kIFdyaXRhYmxlIHN0cmVhbXMgZ2V0IGBfYnl0ZXMoKWAgYW5kIGBfc2tpcEJ5dGVzKClgXG4gIHN0cmVhbS5fYnl0ZXMgPSBfYnl0ZXM7XG4gIHN0cmVhbS5fc2tpcEJ5dGVzID0gX3NraXBCeXRlcztcblxuICAvLyBvbmx5IFRyYW5zZm9ybSBzdHJlYW1zIGdldCB0aGUgYF9wYXNzdGhyb3VnaCgpYCBmdW5jdGlvblxuICBpZiAoaXNUcmFuc2Zvcm0pIHN0cmVhbS5fcGFzc3Rocm91Z2ggPSBfcGFzc3Rocm91Z2g7XG5cbiAgLy8gdGFrZSBjb250cm9sIG9mIHRoZSBzdHJlYW1zMiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHRoaXMgc3RyZWFtXG4gIGlmIChpc1RyYW5zZm9ybSkge1xuICAgIHN0cmVhbS5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5fd3JpdGUgPSB3cml0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChzdHJlYW0pIHtcbiAgZGVidWcoJ2luaXRpYWxpemluZyBwYXJzZXIgc3RyZWFtJyk7XG5cbiAgLy8gbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gcGFyc2VyIGZvciB0aGUgbmV4dCBcImNodW5rXCJcbiAgc3RyZWFtLl9wYXJzZXJCeXRlc0xlZnQgPSAwO1xuXG4gIC8vIGFycmF5IG9mIEJ1ZmZlciBpbnN0YW5jZXMgdGhhdCBtYWtlIHVwIHRoZSBuZXh0IFwiY2h1bmtcIlxuICBzdHJlYW0uX3BhcnNlckJ1ZmZlcnMgPSBbXTtcblxuICAvLyBudW1iZXIgb2YgYnl0ZXMgcGFyc2VkIHNvIGZhciBmb3IgdGhlIG5leHQgXCJjaHVua1wiXG4gIHN0cmVhbS5fcGFyc2VyQnVmZmVyZWQgPSAwO1xuXG4gIC8vIGZsYWcgdGhhdCBrZWVwcyB0cmFjayBvZiBpZiB3aGF0IHRoZSBwYXJzZXIgc2hvdWxkIGRvIHdpdGggYnl0ZXMgcmVjZWl2ZWRcbiAgc3RyZWFtLl9wYXJzZXJTdGF0ZSA9IElOSVQ7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIGZvciB0aGUgbmV4dCBcImNodW5rXCJcbiAgc3RyZWFtLl9wYXJzZXJDYWxsYmFjayA9IG51bGw7XG5cbiAgLy8gWFhYOiBiYWNrd2FyZHMgY29tcGF0IHdpdGggdGhlIG9sZCBUcmFuc2Zvcm0gQVBJLi4uIHJlbW92ZSBhdCBzb21lIHBvaW50Li5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHN0cmVhbS5wdXNoKSB7XG4gICAgc3RyZWFtLl9wYXJzZXJPdXRwdXQgPSBzdHJlYW0ucHVzaC5iaW5kKHN0cmVhbSk7XG4gIH1cblxuICBzdHJlYW0uX3BhcnNlckluaXQgPSB0cnVlO1xufVxuXG4vKipcbiAqIEJ1ZmZlcnMgYG5gIGJ5dGVzIGFuZCB0aGVuIGludm9rZXMgYGZuYCBvbmNlIHRoYXQgYW1vdW50IGhhcyBiZWVuIGNvbGxlY3RlZC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGJ1ZmZlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gYG5gIGJ5dGVzIGFyZSBidWZmZXJlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBfYnl0ZXMgKG4sIGZuKSB7XG4gIGFzc2VydCghdGhpcy5fcGFyc2VyQ2FsbGJhY2ssICd0aGVyZSBpcyBhbHJlYWR5IGEgXCJjYWxsYmFja1wiIHNldCEnKTtcbiAgYXNzZXJ0KGlzRmluaXRlKG4pICYmIG4gPiAwLCAnY2FuIG9ubHkgYnVmZmVyIGEgZmluaXRlIG51bWJlciBvZiBieXRlcyA+IDAsIGdvdCBcIicgKyBuICsgJ1wiJyk7XG4gIGlmICghdGhpcy5fcGFyc2VySW5pdCkgaW5pdCh0aGlzKTtcbiAgZGVidWcoJ2J1ZmZlcmluZyAlbyBieXRlcycsIG4pO1xuICB0aGlzLl9wYXJzZXJCeXRlc0xlZnQgPSBuO1xuICB0aGlzLl9wYXJzZXJDYWxsYmFjayA9IGZuO1xuICB0aGlzLl9wYXJzZXJTdGF0ZSA9IEJVRkZFUklORztcbn1cblxuLyoqXG4gKiBTa2lwcyBvdmVyIHRoZSBuZXh0IGBuYCBieXRlcywgdGhlbiBpbnZva2VzIGBmbmAgb25jZSB0aGF0IGFtb3VudCBoYXNcbiAqIGJlZW4gZGlzY2FyZGVkLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZGlzY2FyZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gYG5gIGJ5dGVzIGhhdmUgYmVlbiBza2lwcGVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIF9za2lwQnl0ZXMgKG4sIGZuKSB7XG4gIGFzc2VydCghdGhpcy5fcGFyc2VyQ2FsbGJhY2ssICd0aGVyZSBpcyBhbHJlYWR5IGEgXCJjYWxsYmFja1wiIHNldCEnKTtcbiAgYXNzZXJ0KG4gPiAwLCAnY2FuIG9ubHkgc2tpcCA+IDAgYnl0ZXMsIGdvdCBcIicgKyBuICsgJ1wiJyk7XG4gIGlmICghdGhpcy5fcGFyc2VySW5pdCkgaW5pdCh0aGlzKTtcbiAgZGVidWcoJ3NraXBwaW5nICVvIGJ5dGVzJywgbik7XG4gIHRoaXMuX3BhcnNlckJ5dGVzTGVmdCA9IG47XG4gIHRoaXMuX3BhcnNlckNhbGxiYWNrID0gZm47XG4gIHRoaXMuX3BhcnNlclN0YXRlID0gU0tJUFBJTkc7XG59XG5cbi8qKlxuICogUGFzc2VzIHRocm91Z2ggYG5gIGJ5dGVzIHRvIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoaXMgc3RyZWFtIHVudG91Y2hlZCxcbiAqIHRoZW4gaW52b2tlcyBgZm5gIG9uY2UgdGhhdCBhbW91bnQgaGFzIGJlZW4gcGFzc2VkIHRocm91Z2guXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBwYXNzIHRocm91Z2hcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIGBuYCBieXRlcyBoYXZlIHBhc3NlZCB0aHJvdWdoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIF9wYXNzdGhyb3VnaCAobiwgZm4pIHtcbiAgYXNzZXJ0KCF0aGlzLl9wYXJzZXJDYWxsYmFjaywgJ1RoZXJlIGlzIGFscmVhZHkgYSBcImNhbGxiYWNrXCIgc2V0IScpO1xuICBhc3NlcnQobiA+IDAsICdjYW4gb25seSBwYXNzIHRocm91Z2ggPiAwIGJ5dGVzLCBnb3QgXCInICsgbiArICdcIicpO1xuICBpZiAoIXRoaXMuX3BhcnNlckluaXQpIGluaXQodGhpcyk7XG4gIGRlYnVnKCdwYXNzaW5nIHRocm91Z2ggJW8gYnl0ZXMnLCBuKTtcbiAgdGhpcy5fcGFyc2VyQnl0ZXNMZWZ0ID0gbjtcbiAgdGhpcy5fcGFyc2VyQ2FsbGJhY2sgPSBmbjtcbiAgdGhpcy5fcGFyc2VyU3RhdGUgPSBQQVNTVEhST1VHSDtcbn1cblxuLyoqXG4gKiBUaGUgYF93cml0ZSgpYCBjYWxsYmFjayBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBmbikge1xuICBpZiAoIXRoaXMuX3BhcnNlckluaXQpIGluaXQodGhpcyk7XG4gIGRlYnVnKCd3cml0ZSglbyBieXRlcyknLCBjaHVuay5sZW5ndGgpO1xuXG4gIC8vIFhYWDogb2xkIFdyaXRhYmxlIHN0cmVhbSBBUEkgY29tcGF0Li4uIHJlbW92ZSBhdCBzb21lIHBvaW50Li4uXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBlbmNvZGluZykgZm4gPSBlbmNvZGluZztcblxuICBkYXRhKHRoaXMsIGNodW5rLCBudWxsLCBmbik7XG59XG5cbi8qKlxuICogVGhlIGBfdHJhbnNmb3JtKClgIGNhbGxiYWNrIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtIChjaHVuaywgb3V0cHV0LCBmbikge1xuICBpZiAoIXRoaXMuX3BhcnNlckluaXQpIGluaXQodGhpcyk7XG4gIGRlYnVnKCd0cmFuc2Zvcm0oJW8gYnl0ZXMpJywgY2h1bmsubGVuZ3RoKTtcblxuICAvLyBYWFg6IG9sZCBUcmFuc2Zvcm0gc3RyZWFtIEFQSSBjb21wYXQuLi4gcmVtb3ZlIGF0IHNvbWUgcG9pbnQuLi5cbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIG91dHB1dCkge1xuICAgIG91dHB1dCA9IHRoaXMuX3BhcnNlck91dHB1dDtcbiAgfVxuXG4gIGRhdGEodGhpcywgY2h1bmssIG91dHB1dCwgZm4pO1xufVxuXG4vKipcbiAqIFRoZSBpbnRlcm5hbCBidWZmZXJpbmcvcGFzc3Rocm91Z2ggbG9naWMuLi5cbiAqXG4gKiBUaGlzIGBfZGF0YWAgZnVuY3Rpb24gZ2V0J3MgXCJ0cmFtcG9saW5lZFwiIHRvIHByZXZlbnQgc3RhY2sgb3ZlcmZsb3dzIGZvciB0aWdodFxuICogbG9vcHMuIFRoaXMgdGVjaG5pcXVlIHJlcXVpcmVzIHVzIHRvIHJldHVybiBhIFwidGh1bmtcIiBmdW5jdGlvbiBmb3IgYW55XG4gKiBzeW5jaHJvbm91cyBhY3Rpb24uIEFzeW5jIHN0dWZmIGJyZWFrcyB0aGUgdHJhbXBvbGluZSwgYnV0IHRoYXQncyBvayBzaW5jZSBpdCdzXG4gKiB3b3JraW5nIHdpdGggYSBuZXcgc3RhY2sgYXQgdGhhdCBwb2ludCBhbnl3YXkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2RhdGEgKHN0cmVhbSwgY2h1bmssIG91dHB1dCwgZm4pIHtcbiAgaWYgKHN0cmVhbS5fcGFyc2VyQnl0ZXNMZWZ0IDw9IDApIHtcbiAgICByZXR1cm4gZm4obmV3IEVycm9yKCdnb3QgZGF0YSBidXQgbm90IGN1cnJlbnRseSBwYXJzaW5nIGFueXRoaW5nJykpO1xuICB9XG5cbiAgaWYgKGNodW5rLmxlbmd0aCA8PSBzdHJlYW0uX3BhcnNlckJ5dGVzTGVmdCkge1xuICAgIC8vIHNtYWxsIGJ1ZmZlciBmaXRzIHdpdGhpbiB0aGUgXCJfcGFyc2VyQnl0ZXNMZWZ0XCIgd2luZG93XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzKHN0cmVhbSwgY2h1bmssIG91dHB1dCwgZm4pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gbGFyZ2UgYnVmZmVyIG5lZWRzIHRvIGJlIHNsaWNlZCBvbiBcIl9wYXJzZXJCeXRlc0xlZnRcIiBhbmQgcHJvY2Vzc2VkXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBiID0gY2h1bmsuc2xpY2UoMCwgc3RyZWFtLl9wYXJzZXJCeXRlc0xlZnQpO1xuICAgICAgcmV0dXJuIHByb2Nlc3Moc3RyZWFtLCBiLCBvdXRwdXQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGZuKGVycik7XG4gICAgICAgIGlmIChjaHVuay5sZW5ndGggPiBiLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2RhdGEoc3RyZWFtLCBjaHVuay5zbGljZShiLmxlbmd0aCksIG91dHB1dCwgZm4pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJuYWwgYHByb2Nlc3NgIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGJ5IHRoZSBgZGF0YWAgZnVuY3Rpb24gd2hlblxuICogc29tZXRoaW5nIFwiaW50ZXJlc3RpbmdcIiBoYXBwZW5zLiBUaGlzIGZ1bmN0aW9uIHRha2VzIGNhcmUgb2YgYnVmZmVyaW5nIHRoZVxuICogYnl0ZXMgd2hlbiBidWZmZXJpbmcsIHBhc3NpbmcgdGhyb3VnaCB0aGUgYnl0ZXMgd2hlbiBkb2luZyB0aGF0LCBhbmQgaW52b2tpbmdcbiAqIHRoZSB1c2VyIGNhbGxiYWNrIHdoZW4gdGhlIG51bWJlciBvZiBieXRlcyBoYXMgYmVlbiByZWFjaGVkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3MgKHN0cmVhbSwgY2h1bmssIG91dHB1dCwgZm4pIHtcbiAgc3RyZWFtLl9wYXJzZXJCeXRlc0xlZnQgLT0gY2h1bmsubGVuZ3RoO1xuICBkZWJ1ZygnJW8gYnl0ZXMgbGVmdCBmb3Igc3RyZWFtIHBpZWNlJywgc3RyZWFtLl9wYXJzZXJCeXRlc0xlZnQpO1xuXG4gIGlmIChzdHJlYW0uX3BhcnNlclN0YXRlID09PSBCVUZGRVJJTkcpIHtcbiAgICAvLyBidWZmZXJcbiAgICBzdHJlYW0uX3BhcnNlckJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgc3RyZWFtLl9wYXJzZXJCdWZmZXJlZCArPSBjaHVuay5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoc3RyZWFtLl9wYXJzZXJTdGF0ZSA9PT0gUEFTU1RIUk9VR0gpIHtcbiAgICAvLyBwYXNzdGhyb3VnaFxuICAgIG91dHB1dChjaHVuayk7XG4gIH1cbiAgLy8gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBmb3IgdGhlIFNLSVBQSU5HIGNhc2VcblxuICBpZiAoMCA9PT0gc3RyZWFtLl9wYXJzZXJCeXRlc0xlZnQpIHtcbiAgICAvLyBkb25lIHdpdGggc3RyZWFtIFwicGllY2VcIiwgaW52b2tlIHRoZSBjYWxsYmFja1xuICAgIHZhciBjYiA9IHN0cmVhbS5fcGFyc2VyQ2FsbGJhY2s7XG4gICAgaWYgKGNiICYmIHN0cmVhbS5fcGFyc2VyU3RhdGUgPT09IEJVRkZFUklORyAmJiBzdHJlYW0uX3BhcnNlckJ1ZmZlcnMubGVuZ3RoID4gMSkge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuY29uY2F0KHN0cmVhbS5fcGFyc2VyQnVmZmVycywgc3RyZWFtLl9wYXJzZXJCdWZmZXJlZCk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uX3BhcnNlclN0YXRlICE9PSBCVUZGRVJJTkcpIHtcbiAgICAgIGNodW5rID0gbnVsbDtcbiAgICB9XG4gICAgc3RyZWFtLl9wYXJzZXJDYWxsYmFjayA9IG51bGw7XG4gICAgc3RyZWFtLl9wYXJzZXJCdWZmZXJlZCA9IDA7XG4gICAgc3RyZWFtLl9wYXJzZXJTdGF0ZSA9IElOSVQ7XG4gICAgc3RyZWFtLl9wYXJzZXJCdWZmZXJzLnNwbGljZSgwKTsgLy8gZW1wdHlcblxuICAgIGlmIChjYikge1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGlmIChjaHVuaykge1xuICAgICAgICAvLyBidWZmZXJlZFxuICAgICAgICBhcmdzLnB1c2goY2h1bmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFzc3Rocm91Z2hcbiAgICAgIH1cbiAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgLy8gb24gYSBUcmFuc2Zvcm0gc3RyZWFtLCBoYXMgXCJvdXRwdXRcIiBmdW5jdGlvblxuICAgICAgICBhcmdzLnB1c2gob3V0cHV0KTtcbiAgICAgIH1cbiAgICAgIHZhciBhc3luYyA9IGNiLmxlbmd0aCA+IGFyZ3MubGVuZ3RoO1xuICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgIGFyZ3MucHVzaCh0cmFtcG9saW5lKGZuKSk7XG4gICAgICB9XG4gICAgICAvLyBpbnZva2UgY2JcbiAgICAgIHZhciBydG4gPSBjYi5hcHBseShzdHJlYW0sIGFyZ3MpO1xuICAgICAgaWYgKCFhc3luYyB8fCBmbiA9PT0gcnRuKSByZXR1cm4gZm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG5lZWQgbW9yZSBieXRlc1xuICAgIHJldHVybiBmbjtcbiAgfVxufVxuXG52YXIgZGF0YSA9IHRyYW1wb2xpbmUoX2RhdGEpO1xuXG4vKipcbiAqIEdlbmVyaWMgdGh1bmstYmFzZWQgXCJ0cmFtcG9saW5lXCIgaGVscGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGlucHV0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gXCJ0cmFtcG9saW5lZFwiIGZ1bmN0aW9uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0cmFtcG9saW5lIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgd2hpbGUgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/stream-parser/index.js\n");

/***/ })

};
;